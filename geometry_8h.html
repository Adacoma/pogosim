<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pogosim: src/pogosim/geometry.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Pogosim
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('geometry_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">geometry.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;SDL2/SDL.h&gt;</code><br />
<code>#include &lt;SDL2/SDL_image.h&gt;</code><br />
<code>#include &lt;box2d/box2d.h&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;tuple&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
</div>
<p><a href="geometry_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3ee73d4e69ef717ee7294518790ed8c3" id="r_a3ee73d4e69ef717ee7294518790ed8c3"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; std::vector&lt; b2Vec2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ee73d4e69ef717ee7294518790ed8c3">arena_polygons_t</a></td></tr>
<tr class="separator:a3ee73d4e69ef717ee7294518790ed8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6f2524a8fca8ad68f61ae3bfb2568805" id="r_a6f2524a8fca8ad68f61ae3bfb2568805"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f2524a8fca8ad68f61ae3bfb2568805">adjust_mm_to_pixels</a> (float delta)</td></tr>
<tr class="memdesc:a6f2524a8fca8ad68f61ae3bfb2568805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the global mm_to_pixels scaling factor.  <br /></td></tr>
<tr class="separator:a6f2524a8fca8ad68f61ae3bfb2568805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26bae0c48b4485fc418034fccaebad7f" id="r_a26bae0c48b4485fc418034fccaebad7f"><td class="memItemLeft" align="right" valign="top">b2Vec2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26bae0c48b4485fc418034fccaebad7f">visualization_position</a> (float x, float y)</td></tr>
<tr class="memdesc:a26bae0c48b4485fc418034fccaebad7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the visualization position for given x and y coordinates.  <br /></td></tr>
<tr class="separator:a26bae0c48b4485fc418034fccaebad7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e76ec292d7df60cf3dbbba91c07e44e" id="r_a8e76ec292d7df60cf3dbbba91c07e44e"><td class="memItemLeft" align="right" valign="top">b2Vec2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e76ec292d7df60cf3dbbba91c07e44e">visualization_position</a> (b2Vec2 pos)</td></tr>
<tr class="memdesc:a8e76ec292d7df60cf3dbbba91c07e44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the visualization position for a given point.  <br /></td></tr>
<tr class="separator:a8e76ec292d7df60cf3dbbba91c07e44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f54e0b530a83fc7354746b3207b5fcb" id="r_a5f54e0b530a83fc7354746b3207b5fcb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; b2Vec2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f54e0b530a83fc7354746b3207b5fcb">read_poly_from_csv</a> (const std::string &amp;filename, float total_surface)</td></tr>
<tr class="memdesc:a5f54e0b530a83fc7354746b3207b5fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads polygons from a CSV file and scales them to match a specified surface area.  <br /></td></tr>
<tr class="separator:a5f54e0b530a83fc7354746b3207b5fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2572b4ee0344bcdc1cee1fd9acf3e3" id="r_aba2572b4ee0344bcdc1cee1fd9acf3e3"><td class="memItemLeft" align="right" valign="top">b2Vec2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba2572b4ee0344bcdc1cee1fd9acf3e3">generate_random_point_within_polygon</a> (const std::vector&lt; b2Vec2 &gt; &amp;polygon)</td></tr>
<tr class="memdesc:aba2572b4ee0344bcdc1cee1fd9acf3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random point within the specified polygon.  <br /></td></tr>
<tr class="separator:aba2572b4ee0344bcdc1cee1fd9acf3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d53ae819a7d994c21d8b60c3866ff4" id="r_ae0d53ae819a7d994c21d8b60c3866ff4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0d53ae819a7d994c21d8b60c3866ff4">is_point_within_polygon</a> (const std::vector&lt; b2Vec2 &gt; &amp;polygon, float x, float y)</td></tr>
<tr class="memdesc:ae0d53ae819a7d994c21d8b60c3866ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a point is within a polygon.  <br /></td></tr>
<tr class="separator:ae0d53ae819a7d994c21d8b60c3866ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c33659f7609a5b225d1874dbe98a0d" id="r_ad6c33659f7609a5b225d1874dbe98a0d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; b2Vec2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6c33659f7609a5b225d1874dbe98a0d">offset_polygon</a> (const std::vector&lt; b2Vec2 &gt; &amp;polygon, float offset)</td></tr>
<tr class="memdesc:ad6c33659f7609a5b225d1874dbe98a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an offset polygon.  <br /></td></tr>
<tr class="separator:ad6c33659f7609a5b225d1874dbe98a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1b8aaa9da731c330f46d786f7eeccc" id="r_acf1b8aaa9da731c330f46d786f7eeccc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; b2Vec2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf1b8aaa9da731c330f46d786f7eeccc">generate_random_points_within_polygon_safe</a> (const std::vector&lt; std::vector&lt; b2Vec2 &gt; &gt; &amp;polygons, const std::vector&lt; float &gt; &amp;reserve_radii, float max_neighbor_distance=std::numeric_limits&lt; float &gt;::infinity(), std::uint32_t attempts_per_point=100U, std::uint32_t max_restarts=100U)</td></tr>
<tr class="separator:acf1b8aaa9da731c330f46d786f7eeccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7d4bbd501fb2d3bd1715469127c5ff" id="r_a5b7d4bbd501fb2d3bd1715469127c5ff"><td class="memItemLeft" align="right" valign="top">std::vector&lt; b2Vec2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b7d4bbd501fb2d3bd1715469127c5ff">generate_points_voronoi_lloyd</a> (const std::vector&lt; std::vector&lt; b2Vec2 &gt; &gt; &amp;polygons, std::size_t k, std::size_t n_samples=20 '000, std::size_t kmeans_iterations=20, std::uint32_t max_restarts=3)</td></tr>
<tr class="separator:a5b7d4bbd501fb2d3bd1715469127c5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af359853bf93f4b8dcf6e0fae04e067a5" id="r_af359853bf93f4b8dcf6e0fae04e067a5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; b2Vec2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af359853bf93f4b8dcf6e0fae04e067a5">generate_random_points_power_lloyd</a> (const std::vector&lt; std::vector&lt; b2Vec2 &gt; &gt; &amp;polygons, const std::vector&lt; float &gt; &amp;reserve_radii, std::size_t n_samples=25 '000, std::size_t kmeans_iterations=25, float convergence_eps=1e-3f, std::uint32_t max_restarts=3)</td></tr>
<tr class="memdesc:af359853bf93f4b8dcf6e0fae04e067a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniformly sample approximately equi-spaced points in a (possibly holed) polygonal domain, while respecting <em>per-point</em> exclusion radii.  <br /></td></tr>
<tr class="separator:af359853bf93f4b8dcf6e0fae04e067a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e89fae9aa98f7ee3469c035a31b2fb" id="r_a19e89fae9aa98f7ee3469c035a31b2fb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; b2Vec2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19e89fae9aa98f7ee3469c035a31b2fb">generate_random_points_layered</a> (const std::vector&lt; std::vector&lt; b2Vec2 &gt; &gt; &amp;polygons, const std::vector&lt; float &gt; &amp;reserve_radii, std::uint32_t attempts_per_point=1 '000U, std::uint32_t max_restarts=25U)</td></tr>
<tr class="separator:a19e89fae9aa98f7ee3469c035a31b2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2304c47bf95803ca27b6011bf7a858" id="r_aba2304c47bf95803ca27b6011bf7a858"><td class="memItemLeft" align="right" valign="top">std::vector&lt; b2Vec2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba2304c47bf95803ca27b6011bf7a858">generate_chessboard_points</a> (const std::vector&lt; std::vector&lt; b2Vec2 &gt; &gt; &amp;polygons, std::size_t n_points, float pitch, bool cluster_center=false)</td></tr>
<tr class="memdesc:aba2304c47bf95803ca27b6011bf7a858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a square-grid ("checkerboard") layout with **exactly <code class="param">n_points**</code> nodes inside a (possibly holed) polygonal arena.  <br /></td></tr>
<tr class="separator:aba2304c47bf95803ca27b6011bf7a858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2c5f60172186fca0daa83407e2a86b" id="r_a8c2c5f60172186fca0daa83407e2a86b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; float, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c2c5f60172186fca0daa83407e2a86b">compute_polygon_dimensions</a> (const std::vector&lt; b2Vec2 &gt; &amp;polygon)</td></tr>
<tr class="memdesc:a8c2c5f60172186fca0daa83407e2a86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the width and height of a polygon.  <br /></td></tr>
<tr class="separator:a8c2c5f60172186fca0daa83407e2a86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ac241a6accd331b86d209dd889a70e" id="r_a15ac241a6accd331b86d209dd889a70e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15ac241a6accd331b86d209dd889a70e">compute_polygon_area</a> (const std::vector&lt; b2Vec2 &gt; &amp;poly)</td></tr>
<tr class="memdesc:a15ac241a6accd331b86d209dd889a70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the area of a polygon using the shoelace formula.  <br /></td></tr>
<tr class="separator:a15ac241a6accd331b86d209dd889a70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d23d86bfb61af34c5a025be7a5325af" id="r_a3d23d86bfb61af34c5a025be7a5325af"><td class="memItemLeft" align="right" valign="top">b2Vec2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d23d86bfb61af34c5a025be7a5325af">polygon_centroid</a> (const std::vector&lt; b2Vec2 &gt; &amp;polygon)</td></tr>
<tr class="memdesc:a3d23d86bfb61af34c5a025be7a5325af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the centroid of a polygon.  <br /></td></tr>
<tr class="separator:a3d23d86bfb61af34c5a025be7a5325af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f8ce7cd9ad47872f165c227fa843d8" id="r_a41f8ce7cd9ad47872f165c227fa843d8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41f8ce7cd9ad47872f165c227fa843d8">point_to_line_segment_distance</a> (const b2Vec2 &amp;p, const b2Vec2 &amp;a, const b2Vec2 &amp;b)</td></tr>
<tr class="memdesc:a41f8ce7cd9ad47872f165c227fa843d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the distance from a point to a line segment.  <br /></td></tr>
<tr class="separator:a41f8ce7cd9ad47872f165c227fa843d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70d032568001cd6f8ad49c68e96cc30" id="r_ab70d032568001cd6f8ad49c68e96cc30"><td class="memItemLeft" align="right" valign="top">std::vector&lt; b2Vec2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab70d032568001cd6f8ad49c68e96cc30">generate_regular_disk_points_in_polygon</a> (const std::vector&lt; std::vector&lt; b2Vec2 &gt; &gt; &amp;polygons, const std::vector&lt; float &gt; &amp;reserve_radii)</td></tr>
<tr class="memdesc:ab70d032568001cd6f8ad49c68e96cc30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place points on (approximate) concentric rings inside polygons[0] so that: • point i stays ≥ reserve_radii[i] from every polygon edge, • point i stays ≥ reserve_radii[i] + reserve_radii[j] from every previously accepted point j, • no point falls inside a hole (polygons[1…]).  <br /></td></tr>
<tr class="separator:ab70d032568001cd6f8ad49c68e96cc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ae44b918ffa60675fb450ec775a444" id="r_a14ae44b918ffa60675fb450ec775a444"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; b2Vec2 &gt;, std::vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14ae44b918ffa60675fb450ec775a444">import_points_from_file</a> (const <a class="el" href="#a3ee73d4e69ef717ee7294518790ed8c3">arena_polygons_t</a> &amp;scaled_arena_polygons, const size_t nb_objects, const std::string &amp;formation_filename, const std::pair&lt; float, float &gt; &amp;imported_formation_min_coords, const std::pair&lt; float, float &gt; &amp;imported_formation_max_coords)</td></tr>
<tr class="memdesc:a14ae44b918ffa60675fb450ec775a444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import and rescale robot formation points.  <br /></td></tr>
<tr class="separator:a14ae44b918ffa60675fb450ec775a444"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af666137c18de281580dbef83201f3a32" id="r_af666137c18de281580dbef83201f3a32"><td class="memItemLeft" align="right" valign="top">float const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af666137c18de281580dbef83201f3a32">VISUALIZATION_SCALE</a> = 100.0f</td></tr>
<tr class="separator:af666137c18de281580dbef83201f3a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57852bee0e7ed3f9ac024c7dffbc0b2" id="r_aa57852bee0e7ed3f9ac024c7dffbc0b2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa57852bee0e7ed3f9ac024c7dffbc0b2">mm_to_pixels</a></td></tr>
<tr class="memdesc:aa57852bee0e7ed3f9ac024c7dffbc0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global scaling factor from millimeters to pixels.  <br /></td></tr>
<tr class="separator:aa57852bee0e7ed3f9ac024c7dffbc0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c2c5d921f6fae8ad89c96487681e6c" id="r_ae8c2c5d921f6fae8ad89c96487681e6c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8c2c5d921f6fae8ad89c96487681e6c">visualization_x</a></td></tr>
<tr class="memdesc:ae8c2c5d921f6fae8ad89c96487681e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global visualization offset for the x-coordinate.  <br /></td></tr>
<tr class="separator:ae8c2c5d921f6fae8ad89c96487681e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a967d94e4b6a2e1d971db97325c468" id="r_a87a967d94e4b6a2e1d971db97325c468"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87a967d94e4b6a2e1d971db97325c468">visualization_y</a></td></tr>
<tr class="memdesc:a87a967d94e4b6a2e1d971db97325c468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global visualization offset for the y-coordinate.  <br /></td></tr>
<tr class="separator:a87a967d94e4b6a2e1d971db97325c468"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a3ee73d4e69ef717ee7294518790ed8c3" name="a3ee73d4e69ef717ee7294518790ed8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee73d4e69ef717ee7294518790ed8c3">&#9670;&#160;</a></span>arena_polygons_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;std::vector&lt;b2Vec2&gt; &gt; <a class="el" href="#a3ee73d4e69ef717ee7294518790ed8c3">arena_polygons_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6f2524a8fca8ad68f61ae3bfb2568805" name="a6f2524a8fca8ad68f61ae3bfb2568805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2524a8fca8ad68f61ae3bfb2568805">&#9670;&#160;</a></span>adjust_mm_to_pixels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void adjust_mm_to_pixels </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>delta</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjusts the global mm_to_pixels scaling factor. </p>
<p>This function modifies the conversion factor from millimeters to pixels by adding the provided delta. The resulting value is clamped between 0.10 and 10.0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delta</td><td>The value to add to mm_to_pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15ac241a6accd331b86d209dd889a70e" name="a15ac241a6accd331b86d209dd889a70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ac241a6accd331b86d209dd889a70e">&#9670;&#160;</a></span>compute_polygon_area()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float compute_polygon_area </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; b2Vec2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>poly</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the area of a polygon using the shoelace formula. </p>
<p>This function calculates the area of a polygon defined by a sequence of points (b2Vec2) using the shoelace algorithm. The formula sums the cross products of consecutive vertices and returns half of the absolute value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>A vector of b2Vec2 points representing the vertices of the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float The computed area of the polygon. </dd></dl>

</div>
</div>
<a id="a8c2c5f60172186fca0daa83407e2a86b" name="a8c2c5f60172186fca0daa83407e2a86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2c5f60172186fca0daa83407e2a86b">&#9670;&#160;</a></span>compute_polygon_dimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; float, float &gt; compute_polygon_dimensions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; b2Vec2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polygon</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the width and height of a polygon. </p>
<p>This function calculates the dimensions of a polygon by determining the minimum and maximum x and y coordinates of its vertices. The width is computed as the difference between the maximum and minimum x values, and the height is the difference between the maximum and minimum y values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td>A vector of b2Vec2 points representing the vertices of the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;float, float&gt; A pair where the first element is the width and the second element is the height of the polygon. </dd></dl>

</div>
</div>
<a id="aba2304c47bf95803ca27b6011bf7a858" name="aba2304c47bf95803ca27b6011bf7a858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2304c47bf95803ca27b6011bf7a858">&#9670;&#160;</a></span>generate_chessboard_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; b2Vec2 &gt; generate_chessboard_points </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; b2Vec2 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polygons</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>pitch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>cluster_center</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a square-grid ("checkerboard") layout with **exactly <code class="param">n_points**</code> nodes inside a (possibly holed) polygonal arena. </p>
<p>The grid is axis-aligned with spacing approximately <code class="param">pitch</code>. The function will try multiple strategies to achieve exactly the requested number of points:</p><ol type="1">
<li>Try exact grid with the given pitch</li>
<li>Try grids with slightly adjusted pitch values</li>
<li>Use grid points as base and add/remove points strategically</li>
<li>For small numbers, use optimized placement</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>0 = outer boundary (≥ 3 vertices), 1…N = holes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_points</td><td>Exact number of nodes requested (≥ 1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitch</td><td>Target grid spacing in metres (&gt; 0) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cluster_center</td><td>If true, creates compact formation centered in arena without holes. If false, uses distributed placement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;b2Vec2&gt; Exactly <code class="param">n_points</code> valid nodes</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>• if <code class="param">pitch</code> ≤ 0 or <code class="param">n_points</code> == 0 <br  />
 • if the outer polygon is missing / degenerate <br  />
 • if it is impossible to place <code class="param">n_points</code> nodes in the arena</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Requires <code>is_point_within_polygon(poly,x,y)</code> treating boundary points as inside. Uses Box2D's <code>b2Vec2</code> for coordinates. </dd></dl>

</div>
</div>
<a id="a5b7d4bbd501fb2d3bd1715469127c5ff" name="a5b7d4bbd501fb2d3bd1715469127c5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7d4bbd501fb2d3bd1715469127c5ff">&#9670;&#160;</a></span>generate_points_voronoi_lloyd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; b2Vec2 &gt; generate_points_voronoi_lloyd </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; b2Vec2 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polygons</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n_samples</em></span><span class="paramdefsep"> = </span><span class="paramdefval">20&#160;'000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>kmeans_iterations</em></span><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>max_restarts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">3</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate approximately equi-spaced random points inside a (possibly holed) polygonal domain by running a few iterations of Lloyd’s relaxation (a.k.a. “K-means” on a dense uniform sample).</p>
<ol type="1">
<li>Draw <code>n_samples</code> uniform random points inside the domain.</li>
<li>Initialise <code>k</code> cluster centres by picking <code>k</code> of those samples at random.</li>
<li>Repeat <code>kmeans_iterations</code> times (or until convergence): • Assign every sample to its closest centre. • Replace each centre by the arithmetic mean of the samples in its cluster. If the mean falls outside the domain, snap it to the in-domain sample that is nearest to the mean.</li>
<li>Return the final centres.</li>
</ol>
<p>In practice after ~15–25 iterations you already get a centroidal Voronoi tessellation good enough for swarm-robot initialisation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygons</td><td>outer polygon first, holes afterwards </td></tr>
    <tr><td class="paramname">k</td><td>number of points to generate </td></tr>
    <tr><td class="paramname">n_samples</td><td>size of the uniform background sample </td></tr>
    <tr><td class="paramname">kmeans_iterations</td><td>maximum number of Lloyd relaxations </td></tr>
    <tr><td class="paramname">max_restarts</td><td>how many times we may restart if a step fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the domain is invalid or no solution is found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba2572b4ee0344bcdc1cee1fd9acf3e3" name="aba2572b4ee0344bcdc1cee1fd9acf3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2572b4ee0344bcdc1cee1fd9acf3e3">&#9670;&#160;</a></span>generate_random_point_within_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">b2Vec2 generate_random_point_within_polygon </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; b2Vec2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polygon</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random point within the specified polygon. </p>
<p>This function calculates the bounding box of the provided polygon and repeatedly generates random points within that box until one is found that lies inside the polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td>A vector of b2Vec2 points defining the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>b2Vec2 A randomly generated point within the polygon.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the polygon has fewer than 3 points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19e89fae9aa98f7ee3469c035a31b2fb" name="a19e89fae9aa98f7ee3469c035a31b2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e89fae9aa98f7ee3469c035a31b2fb">&#9670;&#160;</a></span>generate_random_points_layered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; b2Vec2 &gt; generate_random_points_layered </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; b2Vec2 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polygons</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>reserve_radii</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>attempts_per_point</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1&#160;'000U</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>max_restarts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">25U</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Priority-wall layered sampler.</p>
<p>Stage 0 : fill the boundary (outer wall or hole walls) greedily; Stage 1+ : build concentric layers around the already-accepted points.</p>
<p>A point i always keeps <code>reserve_radii[i]</code> clearance from walls <em>and</em> from every other point. NaN radii → return {NaN,NaN}.</p>
<p>Throws std::runtime_error after <code>max_restarts</code> failed global attempts. </p>

</div>
</div>
<a id="af359853bf93f4b8dcf6e0fae04e067a5" name="af359853bf93f4b8dcf6e0fae04e067a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af359853bf93f4b8dcf6e0fae04e067a5">&#9670;&#160;</a></span>generate_random_points_power_lloyd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; b2Vec2 &gt; generate_random_points_power_lloyd </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; b2Vec2 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polygons</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>reserve_radii</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n_samples</em></span><span class="paramdefsep"> = </span><span class="paramdefval">25&#160;'000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>kmeans_iterations</em></span><span class="paramdefsep"> = </span><span class="paramdefval">25</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>convergence_eps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-3f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>max_restarts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">3</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uniformly sample approximately equi-spaced points in a (possibly holed) polygonal domain, while respecting <em>per-point</em> exclusion radii. </p>
<p>The routine performs <b>Lloyd relaxation in power-distance space</b>:</p><ol type="1">
<li>Draw <code>n_samples</code> uniform random points inside the domain.</li>
<li>Initialise <code>k = reserve_radii.size()</code> centres with random samples.</li>
<li>Iterate <em>kmeans_iterations</em> times (or until all moves &lt; <em>convergence_eps</em>): • Assign every sample to the centre that minimises the power distance ‖p − c‖² − rᵢ². • Replace each centre by the arithmetic mean of its samples. If that mean falls outside the domain, snap it back to the closest <em>in-domain</em> sample in the same cluster.</li>
<li>Run a lightweight “push-apart” pass so that no two centres end up closer than rᵢ + rⱼ (handles the rare residual overlaps).</li>
</ol>
<p>The power metric naturally enlarges Voronoi cells for large radii, giving a blue-noise layout where big robots get more space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygons</td><td>0-th entry = outer boundary, 1…N = holes </td></tr>
    <tr><td class="paramname">reserve_radii</td><td>desired exclusion radius per point (size k) </td></tr>
    <tr><td class="paramname">n_samples</td><td>size of the background uniform sample cloud </td></tr>
    <tr><td class="paramname">kmeans_iterations</td><td>maximum Lloyd iterations (≈15–30 is plenty) </td></tr>
    <tr><td class="paramname">convergence_eps</td><td>stop early if every shift &lt; this (world units) </td></tr>
    <tr><td class="paramname">max_restarts</td><td>number of times we may restart on hard failure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;b2Vec2&gt; the <em>k</em> centre positions</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the domain is invalid or the algorithm fails after <code>max_restarts</code> attempts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf1b8aaa9da731c330f46d786f7eeccc" name="acf1b8aaa9da731c330f46d786f7eeccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1b8aaa9da731c330f46d786f7eeccc">&#9670;&#160;</a></span>generate_random_points_within_polygon_safe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; b2Vec2 &gt; generate_random_points_within_polygon_safe </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; b2Vec2 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polygons</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>reserve_radii</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>max_neighbor_distance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>attempts_per_point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>max_restarts</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate random points inside a (possibly holed) polygonal domain while respecting a per‑point exclusion radius and a global connectivity limit.</p>
<p>A candidate is accepted only if it is:</p><ol type="1">
<li>Inside the outer polygon and outside every “hole” polygon.</li>
<li>At a distance ≥ r_i + r_j from every previously accepted point j.</li>
<li>Within <code>max_neighbor_distance</code> of at least one previously accepted point (unless it is the very first point or <code>max_neighbor_distance</code> is +∞).</li>
</ol>
<p>If radius is NaN for a point, it will be set to {NaN, NaN} in the result.</p>
<p>If it fails to build the whole set after <code>attempts_per_point</code> rejected candidates, the algorithm discards all progress and restarts. It will attempt the whole sampling process up to <code>max_restarts</code> times before throwing.</p>
<p>Generate random points inside a (possibly holed) polygonal domain while respecting a per‑point exclusion radius and a global connectivity limit.</p>
<p>A candidate is accepted only if it is:</p><ol type="1">
<li>Inside the outer polygon and outside every "hole" polygon.</li>
<li>At a distance ≥ r_i + r_j from every previously accepted point j.</li>
<li>Within <code>max_neighbor_distance</code> of at least one previously accepted point (unless it is the very first point or <code>max_neighbor_distance</code> is +∞).</li>
</ol>
<p>If radius is NaN for a point, it will be set to {NaN, NaN} in the result.</p>
<p>If it fails to build the whole set after <code>attempts_per_point</code> rejected candidates, the algorithm discards all progress and restarts. It will attempt the whole sampling process up to <code>max_restarts</code> times before throwing. </p>

</div>
</div>
<a id="ab70d032568001cd6f8ad49c68e96cc30" name="ab70d032568001cd6f8ad49c68e96cc30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70d032568001cd6f8ad49c68e96cc30">&#9670;&#160;</a></span>generate_regular_disk_points_in_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; b2Vec2 &gt; generate_regular_disk_points_in_polygon </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; b2Vec2 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polygons</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>reserve_radii</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place points on (approximate) concentric rings inside polygons[0] so that: • point i stays ≥ reserve_radii[i] from every polygon edge, • point i stays ≥ reserve_radii[i] + reserve_radii[j] from every previously accepted point j, • no point falls inside a hole (polygons[1…]). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygons</td><td>polygons[0] is the main area; polygons[1…] are holes. </td></tr>
    <tr><td class="paramname">reserve_radii</td><td>exclusion radii for each requested point (size N). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;b2Vec2&gt; the generated points (size == reserve_radii.size()). </dd></dl>

</div>
</div>
<a id="a14ae44b918ffa60675fb450ec775a444" name="a14ae44b918ffa60675fb450ec775a444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ae44b918ffa60675fb450ec775a444">&#9670;&#160;</a></span>import_points_from_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; b2Vec2 &gt;, std::vector&lt; float &gt; &gt; import_points_from_file </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a3ee73d4e69ef717ee7294518790ed8c3">arena_polygons_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>scaled_arena_polygons</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>nb_objects</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>formation_filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; float, float &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>imported_formation_min_coords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; float, float &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>imported_formation_max_coords</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import and rescale robot formation points. </p>
<p>This routine loads a formation description from <code class="param">formation_filename</code>, rescales every (x, y) so that the entire formation fits inside the bounding box of <code class="param">scaled_arena_polygons</code>, and preserves θ exactly as provided. The caller must supply the minimum and maximum (x, y) that were present in the file (these can be pre‑computed with a simple pass over the input).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaled_arena_polygons</td><td>Destination geometry (already scaled). </td></tr>
    <tr><td class="paramname">nb_objects</td><td>Number of objects. </td></tr>
    <tr><td class="paramname">formation_filename</td><td>Path to a <em>.csv</em> or <em>.feather</em> file with three numeric columns: <em>x</em>, <em>y</em>, <em>theta</em>. </td></tr>
    <tr><td class="paramname">imported_formation_min_coords</td><td>Minimum (x, y) encountered in the source file. </td></tr>
    <tr><td class="paramname">imported_formation_max_coords</td><td>Maximum (x, y) encountered in the source file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple containing:<ul>
<li><b>std::vector&lt;b2Vec2&gt;</b> – positions mapped to arena space.</li>
<li><b>std::vector&lt;float&gt;</b> – corresponding headings (in radians).</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the file cannot be read or the extension is unsupported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>No attempt is made to normalise θ; it is copied verbatim. </dd></dl>

</div>
</div>
<a id="ae0d53ae819a7d994c21d8b60c3866ff4" name="ae0d53ae819a7d994c21d8b60c3866ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d53ae819a7d994c21d8b60c3866ff4">&#9670;&#160;</a></span>is_point_within_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_point_within_polygon </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; b2Vec2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polygon</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a point is within a polygon. </p>
<p>This function uses a ray-casting algorithm to test whether the point (x, y) lies inside the given polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td>A vector of b2Vec2 points defining the polygon. </td></tr>
    <tr><td class="paramname">x</td><td>The x-coordinate of the point. </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate of the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the point is inside the polygon. </dd>
<dd>
false Otherwise. </dd></dl>

</div>
</div>
<a id="ad6c33659f7609a5b225d1874dbe98a0d" name="ad6c33659f7609a5b225d1874dbe98a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c33659f7609a5b225d1874dbe98a0d">&#9670;&#160;</a></span>offset_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; b2Vec2 &gt; offset_polygon </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; b2Vec2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polygon</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes an offset polygon. </p>
<p>This function generates a new polygon by offsetting the original polygon inward or outward by a specified distance. It calculates normals at each vertex and computes new offset points accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td>A vector of b2Vec2 points defining the original polygon. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset distance to apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;b2Vec2&gt; The resulting offset polygon.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the polygon has fewer than 3 points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41f8ce7cd9ad47872f165c227fa843d8" name="a41f8ce7cd9ad47872f165c227fa843d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f8ce7cd9ad47872f165c227fa843d8">&#9670;&#160;</a></span>point_to_line_segment_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float point_to_line_segment_distance </td>
          <td>(</td>
          <td class="paramtype">const b2Vec2 &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const b2Vec2 &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const b2Vec2 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the distance from a point to a line segment. </p>
<p>This function computes the shortest distance from point p to the line segment defined by endpoints a and b.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point from which the distance is measured. </td></tr>
    <tr><td class="paramname">a</td><td>The first endpoint of the line segment. </td></tr>
    <tr><td class="paramname">b</td><td>The second endpoint of the line segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float The distance from point p to the line segment. </dd></dl>

</div>
</div>
<a id="a3d23d86bfb61af34c5a025be7a5325af" name="a3d23d86bfb61af34c5a025be7a5325af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d23d86bfb61af34c5a025be7a5325af">&#9670;&#160;</a></span>polygon_centroid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">b2Vec2 polygon_centroid </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; b2Vec2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polygon</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the centroid of a polygon. </p>
<p>This function calculates the geometric center of the polygon using the shoelace formula.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td>A vector of b2Vec2 points defining the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>b2Vec2 The centroid of the polygon. </dd></dl>

</div>
</div>
<a id="a5f54e0b530a83fc7354746b3207b5fcb" name="a5f54e0b530a83fc7354746b3207b5fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f54e0b530a83fc7354746b3207b5fcb">&#9670;&#160;</a></span>read_poly_from_csv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; b2Vec2 &gt; &gt; read_poly_from_csv </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>total_surface</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads polygons from a CSV file and scales them to match a specified surface area. </p>
<p>This function loads polygons from a CSV file where each line contains the x and y coordinates separated by a comma. An empty line indicates the end of a polygon. Once the polygons are loaded, the function normalizes all points into the [0,1] range using the overall bounding box of the data. The effective area is then computed as the area of the first (main) polygon minus the sum of the areas of any subsequent polygons (considered holes). A uniform scaling factor is determined so that when applied to the normalized polygons, the effective area becomes equal to the specified total_surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The path to the CSV file containing the polygon vertices. </td></tr>
    <tr><td class="paramname">total_surface</td><td>The desired surface area for the main polygon after subtracting the holes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;std::vector&lt;b2Vec2&gt;&gt; A vector containing the scaled polygons, where each polygon is represented as a vector of b2Vec2 points.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the file cannot be opened, no polygons are loaded, or the effective area (main polygon area minus holes area) is non-positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e76ec292d7df60cf3dbbba91c07e44e" name="a8e76ec292d7df60cf3dbbba91c07e44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e76ec292d7df60cf3dbbba91c07e44e">&#9670;&#160;</a></span>visualization_position() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">b2Vec2 visualization_position </td>
          <td>(</td>
          <td class="paramtype">b2Vec2</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the visualization position for a given point. </p>
<p>This overloaded function converts a b2Vec2 point to visualization coordinates using the global mm_to_pixels scaling factor and visualization offsets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The original position as a b2Vec2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>b2Vec2 The computed visualization position. </dd></dl>

</div>
</div>
<a id="a26bae0c48b4485fc418034fccaebad7f" name="a26bae0c48b4485fc418034fccaebad7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26bae0c48b4485fc418034fccaebad7f">&#9670;&#160;</a></span>visualization_position() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">b2Vec2 visualization_position </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the visualization position for given x and y coordinates. </p>
<p>This function converts physical coordinates to visualization coordinates using the global mm_to_pixels scaling factor and visualization offsets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x-coordinate in the original space. </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate in the original space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>b2Vec2 The computed visualization position. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aa57852bee0e7ed3f9ac024c7dffbc0b2" name="aa57852bee0e7ed3f9ac024c7dffbc0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57852bee0e7ed3f9ac024c7dffbc0b2">&#9670;&#160;</a></span>mm_to_pixels</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float mm_to_pixels</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global scaling factor from millimeters to pixels. </p>

</div>
</div>
<a id="af666137c18de281580dbef83201f3a32" name="af666137c18de281580dbef83201f3a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af666137c18de281580dbef83201f3a32">&#9670;&#160;</a></span>VISUALIZATION_SCALE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float const VISUALIZATION_SCALE = 100.0f</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8c2c5d921f6fae8ad89c96487681e6c" name="ae8c2c5d921f6fae8ad89c96487681e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c2c5d921f6fae8ad89c96487681e6c">&#9670;&#160;</a></span>visualization_x</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float visualization_x</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global visualization offset for the x-coordinate. </p>

</div>
</div>
<a id="a87a967d94e4b6a2e1d971db97325c468" name="a87a967d94e4b6a2e1d971db97325c468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a967d94e4b6a2e1d971db97325c468">&#9670;&#160;</a></span>visualization_y</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float visualization_y</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global visualization offset for the y-coordinate. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_f85cdc19aea2b310451a4c053c8297ff.html">pogosim</a></li><li class="navelem"><a class="el" href="geometry_8h.html">geometry.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
